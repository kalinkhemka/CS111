# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Kalin Khemka
Student ID: 304-336-969
Email: kkhemka@ucla.edu

# Partner 2 (if you're working in a team)
Name: Vir Thakor
Student ID: 304-273-900
Email: virthakor@ucla.edu

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)

We implemented a forking system to make the downloads and uploads in parallel.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

There was a strcpy command which would have caused the buffer overrun problem in
the function "start_download". We changed it to a strncpy, where we limited the
size of the file that could be copied to FILENAMESIZ. This will prevent the
buffer overrun bug. 
Added a check to make sure that if we repeatedly receive requests from the same peer
we continue to allow for other peers to make requests as well.

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

1. Checked for the working directory
2. Increased TASKBUFSIZE to prevent too many peers bug
3. Imposed a limit of 100MiB to prevent unlimited data downloading

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

When we are tasked to execute in evil mode, we fork the system and begin attacking.

Buffer Overflow: attempt an overflow on the file name by creating an input of
junk and writing it to the peer. Send a GET request with a large filename bigger
than the buffer not ending in the null byte so that when the peer attempts to run
strcpy on the filename, the peer will fail if they don't check file name size.

Peer Overflow: repeatedly send requests to the peer in order to cause failure. If
we send a lot of open_sockets to requests for a file, the peer will get bogged down
trying to schedule and service these requests, which fills up the buffer.

Disk Overflow: repeatedly upload data to a peer to overload the disk until failure.

# Extra credit problems
#Extra credit problem: Implemented MD5 Check for file integrity.

# Add any other information you'd like us to know below this line.
